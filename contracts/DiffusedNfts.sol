// SPDX-License-Identifier: MIT
pragma solidity ^0.8.16;

import '@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol';
import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/utils/cryptography/ECDSA.sol';

error DiffusedNfts__SignatureFailed();
error DiffusedNfts__AlreadyMinted();

/**
 * @title AI-generated NFT
 * @author Uladzimir Kireyeu
 * @notice ERC721 compatible contract to prove owning
 * generated picture
 * @dev To mint one would need a signature
 * from the server, it is done to restrict nfts only to
 * ai-generated images
 */
contract DiffusedNfts is ERC721URIStorage, Ownable {
    using ECDSA for bytes32;

    string constant MESSAGE_PREFIX = '\x19Ethereum Signed Message:\n';
    uint256 private s_tokenCounter;
    string private s_chain;
    mapping(string => bool) private s_ifMinted;

    event MintedNft(uint256 indexed tokenId, address indexed owner);

    constructor(string memory chain) ERC721('DiffusedNfts', 'DFT') {
        s_chain = chain;
        s_tokenCounter = 0;
    }

    /**
     * @notice Verifies that signature is
     * generated by the server
     * @dev messageLength can be derived using Buffer.from(concat([toUtf8Bytes(imageUri), sender])).toString('hex')
     * s_chain is added to prevent users from minting using the same signature on multiple chains
     * @param imageUri Generated Image Uri
     * @param messageLength Length of the signed message
     * @param signature Signature provided by the server
     * @return If server signed the message
     */
    function verifySignature(
        string memory imageUri,
        bytes memory messageLength,
        bytes memory signature
    ) private view returns (bool) {
        bytes32 hashedMessage = keccak256(
            abi.encodePacked(
                MESSAGE_PREFIX,
                messageLength,
                imageUri,
                msg.sender,
                s_chain
            )
        );

        return hashedMessage.recover(signature) == owner();
    }

    /**
     * @dev Images will be minted to IPFS
     */
    function _baseURI() internal pure override returns (string memory) {
        return 'ipfs://';
    }

    /**
     * @notice Mints NFT with a given image
     * @dev User must have a signature from the server
     * to perform mint
     * @param imageUri The URI given by the server
     * @param messageLength Length of the message:
     * '0x' + Buffer.from((String(message.length))).toString('hex')
     * @param signature Signature of the message provided by the server
     */
    function mintDiffusedNft(
        string memory imageUri,
        bytes memory messageLength,
        bytes memory signature
    ) public {
        if (!verifySignature(imageUri, messageLength, signature)) {
            revert DiffusedNfts__SignatureFailed();
        }

        /* User might try to remint the image
         * because signature remains valid. It prevents contract from
         * flooding.
         */
        if (s_ifMinted[imageUri]) {
            revert DiffusedNfts__AlreadyMinted();
        }

        s_ifMinted[imageUri] = true;
        s_tokenCounter++;

        emit MintedNft(s_tokenCounter, msg.sender);
        _safeMint(msg.sender, s_tokenCounter);
        _setTokenURI(s_tokenCounter, imageUri);
    }

    /**
     * @dev Renounce is disabled due to the absence of need
     */
    function renounceOwnership() public override {}

    /**
     * @notice Returns id which will be used for the next mint
     */
    function getTokenCounter() external view returns (uint256) {
        return s_tokenCounter;
    }

    function isMinted(string calldata imageUri) external view returns (bool) {
        return s_ifMinted[imageUri];
    }

    function getNetwork() external view returns (string memory) {
        return s_chain;
    }
}
